//
// Copyright (c) 2020 Jason S. McMullan <jason.mcmullan@gmail.com>
//

package pws

import (
	"bytes"
	"encoding/binary"
	"image"
	"io"

	"testing"

	"github.com/ezrec/uv3dp"
	"github.com/google/go-cmp/cmp"
)

var (
	// Collect an empty printable
	emptyPrintable = uv3dp.NewEmptyPrintable(uv3dp.Properties{
		Size: uv3dp.Size{
			X: 10,
			Y: 20,
			Millimeter: uv3dp.SizeMillimeter{
				X: 20.0,
				Y: 40.0,
			},
			Layers:      4, // 2 bottom, 2 normal
			LayerHeight: 0.05,
		},
		Exposure: uv3dp.Exposure{
			LightOnTime:  16.500,
			LightOffTime: 2.250,
			LightPWM:     255,
			LiftHeight:   5.5,
			LiftSpeed:    120.0,
			RetractSpeed: 200.0,
		},
		Bottom: uv3dp.Bottom{
			Count: 2,
			Exposure: uv3dp.Exposure{
				LightOnTime:  16.500,
				LightOffTime: 2.250,
				LightPWM:     255,
				LiftHeight:   5.5,
				LiftSpeed:    120.0,
				RetractSpeed: 200.0,
			},
		},
		Preview: map[uv3dp.PreviewType]image.Image{
			uv3dp.PreviewTypeTiny: image.NewRGBA(image.Rect(0, 0, 1, 1)),
		},
	})

	emptyRawHeader  = []byte{0x41, 0x4e, 0x59, 0x43, 0x55, 0x42, 0x49, 0x43, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xac, 0x26, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x27, 0x1, 0x0, 0x48, 0x45, 0x41, 0x44, 0x45, 0x52, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfa, 0x44, 0xcd, 0xcc, 0x4c, 0x3d, 0x0, 0x0, 0x84, 0x41, 0x0, 0x0, 0x10, 0x40, 0x0, 0x0, 0x84, 0x41, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0xb0, 0x40, 0x0, 0x0, 0x0, 0x40, 0x55, 0x55, 0x55, 0x40, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xa, 0x0, 0x0, 0x0, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x50, 0x52, 0x45, 0x56, 0x49, 0x45, 0x57, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x26, 0x1, 0x0, 0xe0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0xa8, 0x0, 0x0, 0x0}
	emptyRawPreview = make([]byte, defaultPreviewWidth*defaultPreviewHeight*2)
	emptyRawFooter  = []byte{0x4c, 0x41, 0x59, 0x45, 0x52, 0x44, 0x45, 0x46, 0x0, 0x0, 0x0, 0x0, 0x84, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x40, 0x27, 0x1, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb0, 0x40, 0x0, 0x0, 0xf0, 0x42, 0x0, 0x0, 0x84, 0x41, 0xcd, 0xcc, 0x4c, 0x3d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x42, 0x27, 0x1, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb0, 0x40, 0x0, 0x0, 0xf0, 0x42, 0x0, 0x0, 0x84, 0x41, 0xcd, 0xcc, 0x4c, 0x3d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x44, 0x27, 0x1, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb0, 0x40, 0x0, 0x0, 0xf0, 0x42, 0x0, 0x0, 0x84, 0x41, 0xcd, 0xcc, 0x4c, 0x3d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x27, 0x1, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb0, 0x40, 0x0, 0x0, 0xf0, 0x42, 0x0, 0x0, 0x84, 0x41, 0xcd, 0xcc, 0x4c, 0x3d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7d, 0x4b, 0x7d, 0x4b, 0x7d, 0x4b, 0x7d, 0x4b}

	emptyRaw = append(append(emptyRawHeader, emptyRawPreview...), emptyRawFooter...)
)

type bufferMap struct {
	Buffer []byte
	Offset int64
}

func (bm *bufferMap) ReadAt(buff []byte, off int64) (size int, err error) {
	size = copy(buff, bm.Buffer[off:])
	if len(buff) > 0 && size == 0 {
		err = io.EOF
	}
	return
}

func (bm *bufferMap) Read(buff []byte) (size int, err error) {
	size, err = bm.ReadAt(buff, bm.Offset)
	if err != nil {
		return
	}
	bm.Offset += int64(size)
	return
}

func TestEmptyToRaw(t *testing.T) {

	table := []struct {
		Format string
		Raw    []byte
	}{
		{".pws", emptyRaw},
	}

	for _, item := range table {
		formatter := NewFormatter(item.Format)
		formatter.AntiAlias = 1

		buffWriter := &bytes.Buffer{}
		formatter.Encode(buffWriter, emptyPrintable)

		encoded_buff := buffWriter.Bytes()

		emptyRaw := item.Raw
		if !bytes.Equal(encoded_buff, emptyRaw) {
			t.Errorf("%v: expected [%d byte encoding], got [%d byte encoding]", item.Format, len(emptyRaw), len(encoded_buff))
			if len(encoded_buff) == len(emptyRaw) {
				for i := 0; i < len(emptyRaw)-3; i += 4 {
					a := binary.LittleEndian.Uint32(emptyRaw[i : i+4])
					b := binary.LittleEndian.Uint32(encoded_buff[i : i+4])
					if a != b {
						t.Logf("[%05x] %08x != %08x", i, a, b)
					}
				}
			}
		}
	}
}

func TestRawToEmpty(t *testing.T) {
	table := []struct {
		Format string
		Raw    []byte
	}{
		{Format: ".pws", Raw: emptyRaw},
	}

	for _, item := range table {
		formatter := NewFormatter(item.Format)

		emptyRaw := item.Raw
		buffReader := &bufferMap{Buffer: emptyRaw}

		result, err := formatter.Decode(buffReader, int64(len(emptyRaw)))
		if err != nil {
			t.Fatalf("expected nil, got %v", err)
		}

		eProp := emptyPrintable.Properties()
		rProp := result.Properties()

		eProp.Preview = nil
		rProp.Preview = nil

		if !cmp.Equal(eProp, rProp) {
			t.Errorf("expected input printable to match expected printable!")
			t.Logf("%+v", eProp)
			t.Logf("%+v", rProp)
		}
	}
}
