//
// Copyright (c) 2020 Jason S. McMullan <jason.mcmullan@gmail.com>
//

// Package uv3dp is a set of tools for data exchange between UV Resin based 3D printers
package cbddlp

import (
	"bytes"
	"encoding/binary"
	"image"
	"time"

	"testing"

	"github.com/ezrec/uv3dp"
)

func TestEmptyCbddlp(t *testing.T) {

	// Collect an empty printable
	prop := uv3dp.Properties{
		Size: uv3dp.Size{
			X: 10,
			Y: 20,
			Millimeter: uv3dp.SizeMillimeter{
				X: 20.0,
				Y: 40.0,
			},
			Layers:      4, // 2 bottom, 2 normal
			LayerHeight: 0.05,
		},
		Exposure: uv3dp.Exposure{
			LightExposure: time.Millisecond * 16500,
			LightOffTime:  time.Millisecond * 2250,
			LiftHeight:    5.5,
			LiftSpeed:     120.0,
			RetractHeight: 3.3,
			RetractSpeed:  200.0,
		},
		Bottom: uv3dp.Bottom{
			Count: 2,
			Exposure: uv3dp.Exposure{
				LightExposure: time.Millisecond * 16500,
				LightOffTime:  time.Millisecond * 2250,
				LiftHeight:    5.5,
				LiftSpeed:     120.0,
				RetractHeight: 3.3,
				RetractSpeed:  200.0,
			},
		},
		Preview: map[uv3dp.PreviewType]image.Image{
			uv3dp.PreviewTypeTiny: image.NewRGBA(image.Rect(0, 0, 10, 10)),
			uv3dp.PreviewTypeHuge: image.NewCMYK(image.Rect(0, 0, 20, 12)),
		},
	}

	expected_buff := []byte{0x19, 0x0, 0xfd, 0x12, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa0, 0x41, 0x0,
		0x0, 0x20, 0x42, 0x0, 0x0, 0x1b, 0x43, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0xcd, 0xcc, 0x4c, 0x3d, 0x0, 0x0, 0x84, 0x41, 0x0, 0x0, 0x84,
		0x41, 0x00, 0x00, 0x10, 0x40, 0x2, 0x0, 0x0, 0x0, 0xa, 0x0, 0x0, 0x0, 0x14, 0x0,
		0x0, 0x0, 0x70, 0x0, 0x0, 0x0, 0xf4, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x94,
		0x0, 0x0, 0x0, 0x4b, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xb8, 0x0, 0x0, 0x0,
		0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x0, 0xff, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x14, 0x0, 0x0, 0x0, 0xc, 0x0,
		0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0xff, 0xff, 0xef, 0x30, 0xa,
		0x0, 0x0, 0x0, 0xa, 0x0, 0x0, 0x0, 0xb4, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x20, 0x0, 0x63, 0x30, 0x0, 0x0, 0xb0, 0x40, 0x0, 0x0, 0xf0, 0x42, 0x0, 0x0,
		0xb0, 0x40, 0x0, 0x0, 0xf0, 0x42, 0x0, 0x0, 0x48, 0x43, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x10, 0x40,
		0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x84, 0x41,
		0x00, 0x00, 0x10, 0x40, 0x84, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0xcd, 0xcc, 0x4c, 0x3d, 0x0, 0x0, 0x84, 0x41,
		0x00, 0x00, 0x10, 0x40, 0x84, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0xcd, 0xcc, 0xcc, 0x3d, 0x0, 0x0, 0x84, 0x41, 0x00, 0x00, 0x10, 0x40, 0x84, 0x1,
		0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a, 0x99, 0x19, 0x3e, 0x0, 0x0, 0x84, 0x41,
		0x00, 0x00, 0x10, 0x40, 0x84, 0x1, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7d, 0x4b}

	empty := uv3dp.NewEmptyPrintable(prop)

	formatter := NewCbddlpFormatter(".cbddlp")

	buffWriter := &bytes.Buffer{}
	formatter.Encode(buffWriter, empty)

	encoded_buff := buffWriter.Bytes()

	if !bytes.Equal(encoded_buff, expected_buff) {
		t.Errorf("expected [%d byte encoding], got [%d byte encoding]", len(expected_buff), len(encoded_buff))
		if len(encoded_buff) == len(expected_buff) {
			for i := 0; i < len(expected_buff)-3; i += 4 {
				a := binary.LittleEndian.Uint32(expected_buff[i : i+4])
				b := binary.LittleEndian.Uint32(encoded_buff[i : i+4])
				if a != b {
					t.Logf("[%05x] %08x != %08x", i, a, b)
				}
			}
		}
	}
}
